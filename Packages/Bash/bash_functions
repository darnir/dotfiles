#!/bin/bash

# Bash Utility Functions

# Function: pastebin()
# Expects data on standard input that is then sent to ix.io for sharing text
# snipets. The URL of the file on ix.io is printed to screen.
pastebin() {
    if [ $# -gt 0 ]
    then
        _error "This function only accepts input from stdin"
        return 100
    fi
    curl -F 'f:1=<-' ix.io;
}

# Function: tre()
# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
tre() {
    tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX;
}

# Function: cov-make()
# This function is specifically geared towards creating a coverity build package
# for my Wget code base. This function isn't portable since it was written to
# simplify only my work.
cov-make() {
    _info "Running cov-make, the Coverity Wrapper for my Wget"
    if [ $PWD != "$HOME/Programming/wget" ]
    then
        _error "This function should only be run from the Wget source dir \
located at: ~/Programming/wget/"
        return 100
    elif [ -z ${COV_TOKEN+x} ]
    then
        _error "Bash secrets were not sourced. Please source the bash secrets"
        return 100
    fi
    _info "Running `make clean`."
    make clean
    _info "Configure Wget with GCC."
    configwget gcc
    _info "Running cov-build..."
    cov-build --dir cov-int make

    COMPILED_UNITS=$(grep -o -e [0-9][0-9].% cov-int/build-log.txt)
    if [[ $COMPILED_UNITS != "100%" ]]
    then
        _info "Compiled Units: $COMPILED_UNITS"
        _error "Not all units compiled. Please check cov-int/build-log.txt"
        return 100
    fi

    _info "Packing the coverity build files"
    tar czvf wget.tgz cov-int

    local version=$(git describe --always | sed 's|-|.|g')

    _info "Uploading Coverity Build to the server"
    curl --form project=GNU+Wget \
  --form token=${COV_TOKEN}\
  --form email=darnir@gmail.com \
  --form file=@wget.tgz \
  --form version="${version}"\
  --form description="\"Coverity build for GNU Wget\"" \
  https://scan.coverity.com/builds?project=GNU+Wget
}

# Function: calc()
# This is a simple command line calculator for Bash. It uses bc to compute
# various results. Give it a valid bc expression and this function will try to
# evaluate its value. Complex output may cause problems on the printf statement.
calc() {
    local result="";
    result="$(printf "scale=10;$*\n" | bc --mathlib | tr -d '\\\n')";
    #                           └─ default (when `--mathlib` is used) is 20
    #
    if [[ "$result" == *.* ]]; then
        # improve the output for decimal numbers
        printf "$result" |
        sed -e 's/^\./0./' `# add "0" for cases like ".5"` \
            -e 's/^-\./-0./' `# add "0" for cases like "-.5"`\
            -e 's/0*$//;s/\.$//'; # remove trailing zeros
    else
        printf "$result";
    fi;
    printf "\n";
}

# Function: pdflatex()
# This function invokes the similarly named /usr/bin/pdflatex binary and uses
# grep to colour the output and highlight the errors and warnings when running
# pdflatex.
pdflatex() {
GREP="grep --color=always --line-buffered"
LL=$*
echo "$LL"
(/usr/bin/pdflatex -file-line-error "$LL" 2>&1) \
 | $GREP -vP "^\s*((\[|\]|\(|\))\s*)+$" \
 | GREP_COLOR="01;31" $GREP -P "(^[^:]*:\d+: )|(^l\.\d+ )|(^! LaTeX Error: )|$" \
 | GREP_COLOR="00;33" $GREP -P "(LaTeX Warning(:|))|(Package [^\s]+ Warning(:|))|$" \
 | GREP_COLOR="00;32" $GREP -P "^Output written on .*\.pdf \(.*\)\.$|$" \
 | uniq
}

# Function: man()
# Similar to pdflatex, this function is invoked when someone tries to load a man
# page. It adds some amount of syntax colouring to the man page to make it
# easier to scan visually.
man() {
    env \
        LESS_TERMCAP_mb=$'\x1b[38;2;255;200;200m' \
    	LESS_TERMCAP_md=$'\x1b[38;2;20;240;240m' \
    	LESS_TERMCAP_me=$'\x1b[0m' \
    	LESS_TERMCAP_so=$'\x1b[38;2;60;90;90;48;2;40;40;40m' \
    	LESS_TERMCAP_se=$'\x1b[0m' \
    	LESS_TERMCAP_us=$'\x1b[38;2;150;100;200m' \
    	LESS_TERMCAP_ue=$'\x1b[0m' \
    	man "$@"
}

# Function: resolve()
# Expects a filename as a parameter at $1.
# A file named $1.pacnew should also exist. This function will then invoke
# vimdiff to diff the files for resolving the conflicts.
# This is a very crude function with little to no error checking and should be
# invoked with care.
resolve() {
    vimdiff "$1" "$1.pacnew"
    read -p "Were the conflicts resolved? [Y/N]: " yn
    case $yn in
        [Yy]* ) _info "Deleting pacnew file"; sudo rm "$1.pacnew";;
    esac
}

# Function: extract()
# Expects a compressed file as a paramter
# This is a utility function I copied from the Arch Wiki. This function accepts
# a filename as a parameter and based on the filename it will run the respective
# utility to decompress the file. The way this function is written, it can be
# used even with older versions of tar which do not have filename based
# detection of the algorithm.
extract() {
    local c e i

    (($#)) || return

    for i; do
        c=''
        e=1

        if [[ ! -r $i ]]; then
            echo "$0: file is unreadable: \`$i'" >&2
            continue
        fi

        case $i in
        *.t@(gz|lz|xz|b@(2|z?(2))|a@(z|r?(.@(Z|bz?(2)|gz|lzma|xz)))))
               c='bsdtar xvf';;
        *.7z)  c='7z x';;
        *.Z)   c='uncompress';;
        *.bz2) c='bunzip2';;
        *.exe) c='cabextract';;
        *.gz)  c='gunzip';;
        *.rar) c='unrar x';;
        *.xz)  c='unxz';;
        *.zip) c='unzip';;
        *)     echo "$0: unrecognized file extension: \`$i'" >&2
               continue;;
        esac

        command $c "$i"
        e=$?
    done

    return $e
}

# Function: pack()
# Expects a filename with a valid extension as the first paramter. All other
# parameters list the files that need to be included in the compressed file.
# This function is the dual of the above extract() function. Given a filename,
# it recognizes the type and creates the respective compressed file containing
# all the files provided on the command line.
pack() {
  local FILE
  FILE=$1
  case $FILE in
    *.tar.bz2)  shift && tar cjf "$FILE" "$*" ;;
    *.tbz2)     shift && tar cjf "$FILE" "$*" ;;
    *.tar.gz)   shift && tar czf "$FILE" "$*" ;;
    *.tgz)      shift && tar czf "$FILE" "$*" ;;
    *.zip)      shift && zip "$FILE" "$*"     ;;
    *.rar)      shift && rar "$FILE" "$*"     ;;
  esac
}

# Function: note()
# Another simple but extremely useful utlity function. This was copied from the
# ArchWiki too. Expects a bunch of text as its parameters which is then stored
# in ~/.notes file.
# Commands:
# Add a new note:  $ note <Enter note here>
# Display notes:   $ note
# Clean all notes: $ note -c
note () {

    NOTES="$HOME/.notes"
    #if file doesn't exist, create it
    [ -f "$NOTES" ] || touch "$NOTES"
    #no arguments, print file
    if [ $# = 0 ]
    then
        cat "$NOTES"
    #clear file
    elif [ "$1" = -c ]
    then
        > "$NOTES"
    #add all arguments to file
    else
        echo "$@" >> "$NOTES"
    fi
}

# Function: pdf()
#
# Expects a pdf file as an argument.
# This is a simple helper function to asynchronously launch a pdf viewer (evince) from
# the command line without polluting it. If the "-o" switch is passed, then Okular
# will be used as the PDF viewer.
pdf() {
    if [[ "$1" == "-o" ]]; then
        okular "$2" &> /dev/null &
    else
        evince "$1" &>/dev/null &
    fi
}

# Function: pdftools()
#
# Simple common operations to perform on a (set of) PDF file(s) +

# Actions:
#   compress:  Compress a PDF to reduce quality and space
#   join:      Join multiple PDF files into a single file
pdftools() {
    ACTION="$1"
    case $ACTION in
        compress) gs -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dPDFSETTINGS=/ebook -sOutputFile="$2" "$3";;
        join) gs -dBATCH -dNOPAUSE -q -sDEVICE=pdfwrite -dPDFSETTINGS=/prepress -sOutputFile="$2" "${@:3}";;
    esac
}

# Function: timer()
# Usage: timer [time] [message]
# This function takes a time argument that is acceptable to sleep(1) and a
# message. After a period of [time], the message is displayed on the screen and
# a audio beep is generated. For the beep to be played, ensure that the beep
# channel in ALSA is not muted.
timer() {
    if [ $# -ne 2 ]
    then
        echo "Usage: timer [time] [message]"
        return 1
    fi
    sleep "$1" && alert && zenity --info --text="$2" &> /dev/null &
}

# Function: screen()
# Usage: screen [preset]
# This function overrides the call to /usr/bin/screen. There exist a number of
# screen presets in $HOME. When $1 to this function matches an existing preset,
# this function invokes screen with the respective screenrc file. As a result it
# can be used to quickly set up a development environment for multiple projects.
screen() {
    filename=".screenrc_$1"
    filepath="$HOME/$filename"
    if [[ -f $filepath ]]
    then
        /usr/bin/screen -c "$filepath"
    else
        /usr/bin/screen $*
    fi
}

ssh-genkey() {
    if [[ -z $1 ]]
    then
        echo -e "Usage: ssh-genkey [name]"
        return 1
    fi
    mkdir "$HOME/.ssh/$1"
    ssh-keygen -C "darnir@gmail.com" -f "$HOME/.ssh/$1/id_rsa"

    cat <<EOF >> $HOME/.ssh/config

Host $1.com
    User darnir
    Hostname $1.com
    PreferredAuthentications publickey
    IdentityFile ~/.ssh/$1/id_rsa
EOF

    echo "Identity Settings written to config file. Please verify:"
    vim "$HOME/.ssh/config"
}

fork() {
    $* &> /dev/null &
}

configwget() {
    # _CFLAGS="-g -g3 -O0 -Wall -Wextra -Wpedantic -Wno-missing-field-initializers -fdiagnostics-color=auto"
    _CFLAGS="-std=gnu99 -pedantic -g -g3 -O0 -Wall -Wextra -Wstrict-prototypes -Wold-style-definition -Wwrite-strings -Wshadow -Wformat -Wformat-security -Wunreachable-code -Wstrict-prototypes -Wmissing-prototypes -Wold-style-definition -fdiagnostics-color=auto"
    _CC="clang"
    _CONFOPT="--enable-option-checking
              --disable-silent-rules
              --enable-dependency-tracking
              --with-ssl=openssl
              --without-included-regex
              --enable-nls
              --enable-assert
              --prefix=/usr"
    _clang_CONFOPT="-C"
    _gcc_CONFOPT=""

    if [[ "$1" == "gcc" ]]; then
        _CC="gcc"
        shift
    fi

    _CC_CONFOPT="_${_CC}_CONFOPT"
    CC=${_CC} time ./configure $_CONFOPT ${!_CC_CONFOPT} $* CFLAGS="$_CFLAGS"
}

cleanswap() {
    SWDEV=$(swapon -s | tail -1 | awk '{print $1}')
    sudo swapoff $SWDEV
    sudo swapon $SWDEV
}

rtems() {
    if [[ $# -eq 0 ]]; then
        _ver="4.12"
    else
        _ver="$1"
    fi

    pushd "$HOME/Programming/rtems"
    source venv-rtems/bin/activate
    export PATH=$HOME/Programming/rtems/$_ver/bin:$PATH
    export RTEMS_ACTIVE=1
    export RTEMS_VER="$_ver"
    unset CC
    export PS1="\n"${SH_WHITE}${TL_ANGLE}"("${SH_BLUE}"\u"${SH_WHITE}"@"${SH_RED}"\h"${SH_WHITE}")"${HORIZ_LINE}"("${SH_GREEN}"\$?"${SH_WHITE}")"${HORIZ_LINE}"("${SH_GREEN}${BATT}${SH_WHITE}")"${HORIZ_LINE}"("${SH_GREEN}"\@ \d"${SH_WHITE}")"${HORIZ_LINE}"("${SH_RED}"RTEMS $_ver"${SH_WHITE}")\n"${BL_ANGLE}${HORIZ_LINE}"("${SH_GREEN}"\w"${SH_WHITE}")"${HORIZ_LINE}"("${SH_YELLOW}${FILES_STAT}" files, "${FILES_SIZE}${SH_WHITE}")"${HORIZ_LINE}${SH_BLUE}${GIT_PS1}${SH_WHITE}"> "${OUT_COL}

    alias qemu-run="qemu-system-arm -no-reboot -net none -nographic -M realview-pbx-a9 -m 256M -smp 4 -icount 8 -kernel *.exe"
    alias qemu-gdb="qemu-system-arm -no-reboot -net none -nographic -M realview-pbx-a9 -m 256M -smp 4 -icount 8 -s -S -kernel *.exe"
    alias rtems-gdb="arm-rtems4.12-gdb --command $HOME/Programming/rtems/arm.gdb *.exe"
    alias kill-qemu="killall qemu-system-arm"
}

awget() {
    local URL="$1"
    local WGET_PARAM="${@:2}"

    local USER="go7box"
    local PASS=$(pass Server/rutorrent/${USER})

    # local _final_url=$(sed -e "s#\(https://\)#\1${USER}:${PASS}@#" <<< "$URL")

    # echo "$_final_url"

    # mpv --cache=204800 --cache-initial=10240 --cache-secs=100 "$_final_url"
    wget2 --progress bar --user ${USER} --password "${PASS}" $WGET_PARAM "$URL"
}

stream() {
    local URL="$1"
    local MPV_PARAM="${@:2}"

    local USER="go7box"
    local PASS=$(pass Server/rutorrent/${USER})

    local _final_url=$(sed -e "s#\(https://\)#\1${USER}:${PASS}@#" <<< "$URL")

    echo "$_final_url"

    # mpv --cache=204800 --cache-initial=10240 --cache-secs=100 "$_final_url"
    mpv --cache=204800 --cache-secs=100 $MPV_PARAM "$_final_url"
}

buildmutt() {
    if [[ $1 == "prepare" ]]; then
        ./prepare                   \
            --prefix=/usr           \
            --sysconfdir=/etc       \
            --enable-debug          \
            --enable-pgp            \
            --enable-smime          \
            --enable-sidebar        \
            --enable-gpgme          \
            --enable-notmuch        \
            --enable-compressed     \
            --enable-pop            \
            --enable-imap           \
            --enable-smtp           \
            --enable-nntp           \
            --enable-exact-address  \
            --enable-hcache         \
            --with-curses=/usr      \
            --with-regex            \
            --with-gss              \
            --with-ssl              \
            --with-sasl             \
            --with-idn
    elif [[ $1 == "build" ]]; then
        make
    fi
}

distos() {
    PIDFILE="/tmp/.ds-deb7.lock"
    if [[ "$1" == "gui" ]]; then
        OPTS="-usbdevice tablet"
    else
        OPTS="-vga none -nographic"
    fi

    if [[ ! -f $PIDFILE ]]; then
        qemu-system-x86_64 \
            -enable-kvm \
            -net user,hostfwd=tcp::8022-:22 \
            -net nic,model=virtio  \
            -m 1G,slots=2,maxmem=3G  \
            -name "Distributed Systems: Fedora" \
            -pidfile "$PIDFILE" \
            -cpu host \
            -M 1.6 \
            -machine type=pc,accel=kvm \
            ${OPTS} \
            -boot order=c \
            -drive file="$HOME/VirtualBox VMs/DistributedSystems/DS-Fedora/DS-Fedora.raw",format=raw,aio=native,cache=none
    else
        echo "Found existing PID file"
        PID=$(pgrep qemu-system-x86)
        if [[ -z $PID ]]; then
            echo "... But qemu process not found. Cleaning up PIDFile"
            rm -v -f "$PIDFILE"
            return 1
        fi
        echo "Trying to SSH into Virtual Machine ..."
        ssh "distos"
    fi
}

rustos() {

    _ARCH="x86_64"

    export RUSTOSDEV=true
    export PATH="$HOME/Programming/Rust-OS/toolchain/install/arch/${_ARCH}/bin":$PATH

    export PS1="\n"${SH_WHITE}${TL_ANGLE}"("${SH_BLUE}"\u"${SH_WHITE}"@"${SH_RED}"\h"${SH_WHITE}")"${HORIZ_LINE}"("${SH_GREEN}"\$?"${SH_WHITE}")"${HORIZ_LINE}"("${SH_GREEN}${BATT}${SH_WHITE}")"${HORIZ_LINE}"("${SH_GREEN}"\@ \d"${SH_WHITE}")"${HORIZ_LINE}"("${SH_RED}"RUSTOS"${SH_WHITE}")\n"${BL_ANGLE}${HORIZ_LINE}"("${SH_GREEN}"\w"${SH_WHITE}")"${HORIZ_LINE}"("${SH_YELLOW}${FILES_STAT}" files, "${FILES_SIZE}${SH_WHITE}")"${HORIZ_LINE}${SH_BLUE}${GIT_PS1}${SH_WHITE}"> "${OUT_COL}
}

# vim: set ft=sh ts=4 sts=4 sw=4 tw=80 et :
